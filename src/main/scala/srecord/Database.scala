package srecord

import scala.collection.mutable.{Map => MMap}
import scala.collection.mutable.ArrayBuffer

import srecord.jdbc.SQL
import srecord.jdbc.Statement

import JDBCTypes._

trait Database {
  protected val _tables = MMap[String, Table]()
  
  val databaseName: String
  
  def tables: List[Table] = _tables.values.toList
  
  def table(name: String): Option[Table] = _tables.get(name)
  
  def +=(table: Table) {
    //println("add table "+table.tableName+" "+table.hashCode)
    _tables += ((table.tableName, table))
  }
  
  // def indexes: List[Index]
  
  trait Table {
    type PK <: Product 
    type ROW <: Row

    protected val _columns = new ArrayBuffer[ColumnDef[_]]
    protected val _primaryKeys = new ArrayBuffer[ColumnDef[_]]

/*    
    def primaryKeys: List[ColumnDef[_]] = {
      synchronized { _columns.toList }
    }
*/    
    def columns: List[ColumnDef[_]] = {
      synchronized { _columns.toList }
    }
    
    def column(name: String): Option[ColumnDef[_]] = {
      synchronized { _columns.find(_.columnName == name) }
    }
    
    def +=(column: ColumnDef[_]) {
      synchronized {
        _columns += column
        if (column.primaryKey) _primaryKeys += column
      }
    }
    
    abstract class ColumnDef[T](val jdbcType: JDBCTypes.JDBCType[T]) {
      def columnName: String
      def nullable: Boolean
      def defaultValue: T = null.asInstanceOf[T]
      def primaryKey: Boolean = false
      def autoGenerated: Boolean = false
      def table = Table.this
      def read(row: Statement#Row) : Any = {
        jdbcType.asInstanceOf[JDBCTypes.JDBCType[_]] match {
          case BOOLEAN => row.nextBoolean
          case DATE => row.nextDate
          case TIMESTAMP => row.nextDate
          case INTEGER => row.nextInt
          case LONG => row.nextLong
          case FLOAT => row.nextFloat
          case DOUBLE => row.nextDouble
          case STRING => row.nextString
        }
      }
      Table.this += this
      override def toString = "ColumnDef: " + (if (columnName != null) columnName else "NO_NAME?")
    }
    
    abstract class PrimaryKey[T](jdbcType: JDBCTypes.JDBCType[T]) extends ColumnDef[T](jdbcType) {
      def nullable = false
      override val primaryKey: Boolean = true
    }
    
    def tableName: String

    val database: Database.this.type = Database.this

    def foreignKey[TABLE <: Table, T](t: TABLE, c: Table#ColumnDef[T]): ColumnDef[T] = error("todo")
    
    protected def findKey(key: PK): Option[ROW] = {
      //println("key: "+key)
      val rows = SQL.query("SELECT * FROM " + tableName + " WHERE " + andPrimaryKeys, toSeq(key): _*) 
      { row =>
          val r = createKey(key)
          _columns.foreach { c =>
            val v = c.read(row)
            r.fields += ((c, v))
            //println("read col: "+c+" value: "+v)
          }
          r
        }
      rows.firstOption
    }
    
    def insert(r: ROW) {
      // _columns.map(c => r.fields(c)).foreach(v => println("insert value: "+v))
      SQL.execute("INSERT INTO " + tableName + " VALUES (" + _columns.map(c => "?").mkString(", ") + ")", _columns.map(c => r.fields(c)): _*) 
    }

    def delete(key: PK) {
      SQL.execute("DELETE FROM " + tableName + " WHERE " + andPrimaryKeys, toSeq(key): _*)
    }

    def delete(r: ROW) { delete(primaryKeyValue(r)) }

    private def andPrimaryKeys = _primaryKeys.map(_.columnName + " = ?").mkString(" AND ")
    
    private def selectWithColumnValues(tableName: String, columnNames: String*) =
      "SELECT * FROM " + tableName + " WHERE " + ( columnNames.map(_ + " = ?") mkString ("(", ") AND (", ")") )

    private def selectWithExpression(tableName: String, expression: String) =
      "SELECT * FROM " + tableName + " WHERE " + expression

    private def deleteWithColumnValues(tableName: String, columnNames: String*) =
      "DELETE FROM " + tableName + " WHERE " + ( columnNames.map(_ + " = ?") mkString ("(", ") AND (", ")") )

    private def toRow(r: Statement#Row) = {
      val fields = new ArrayBuffer[Any]
      _columns.foreach { c =>
        fields += c.read(r)
        //println("read col: "+c+" value: "+v)
      }
      val key = toTuple(fields.take(_primaryKeys.length))
      val row = createKey(key.asInstanceOf[PK])
      var index = 0
      _columns.foreach { c => 
        if (!c.primaryKey) row.fields += ((c,fields(index)))
        index += 1
      }
      row
    }
    
    def query(e: Expression): Seq[ROW] = {
      Console println "expression: %S".format(e.toSQL)
      Console println "arguments: %S".format(e.arguments.mkString("'", "', '", "'"))
      SQL.query(selectWithExpression(tableName, e.toSQL), e.arguments : _*) { toRow _ }
    }

    def query[A](c: ColumnDef[A], a: A): Seq[ROW] = {
      SQL.query(selectWithColumnValues(tableName, c.columnName), a) { toRow _ }
    }

    def queryFirst[A](c: ColumnDef[A], a: A): Option[ROW] = {
      SQL.queryFirst(selectWithColumnValues(tableName, c.columnName), a) { toRow _ }
    }
    
    def query(pairs: (ColumnDef[_], Any)*): Seq[ROW] = {
      SQL.query(selectWithColumnValues(tableName, pairs.map(_._1.columnName): _*), pairs.map(_._2): _*) { toRow _ }
    }

    def queryFirst(pairs: (ColumnDef[_], Any)*): Option[ROW] = {
      SQL.queryFirst(selectWithColumnValues(tableName, pairs.map(_._1.columnName): _*), pairs.map(_._2): _*) { toRow _ }
    }

    def delete[A](c: ColumnDef[A], a: A): Int = {
      SQL.execute(deleteWithColumnValues(tableName, c.columnName), a)
    }

    def delete(pairs: (ColumnDef[_], Any)*): Int = {
      SQL.execute(deleteWithColumnValues(tableName, pairs.map(_._1.columnName): _*), pairs.map(_._2): _*)
    }

    sealed trait ResultOrder {
      def toSQL: String
    }
    case object Ascending extends ResultOrder {
      def toSQL = "ASC"
    }
    case object Descending extends ResultOrder {
      def toSQL = "DESC"
    }
    
    trait Expression {
      def toSQL: String
      def arguments: Seq[_]
      def and(e: Expression) = AndExpression(this, e)
      def or(e: Expression) = OrExpression(this, e)
      def orderBy(c: ColumnDef[_]): Expression = orderBy((c, Ascending))
      def orderBy(c: ColumnDef[_], order: ResultOrder): Expression = orderBy((c, order))
      def orderBy(ordering: (ColumnDef[_], ResultOrder)*): Expression = OrderByExpression(this, ordering: _*)
    }

    case class BasicExpression[T](c: ColumnDef[_], operator: String, t: T) extends Expression {     
      def toSQL = "%s %s ?".format(c.columnName, operator)
      def arguments = List(t)
    }
    
    case class AndExpression(e1: Expression, e2: Expression) extends Expression {
      def toSQL = "(%s) AND (%s)".format(e1.toSQL, e2.toSQL)
      def arguments = e1.arguments ++ e2.arguments
    }
    
    case class OrExpression(e1: Expression, e2: Expression) extends Expression {
      def toSQL = "(%s) OR (%s)".format(e1.toSQL, e2.toSQL)
      def arguments = e1.arguments ++ e2.arguments
    }

    case class OrderByExpression
    (
      e: Expression, 
      ordering: (ColumnDef[_], ResultOrder)*
    ) 
      extends Expression
    {
      def toSQL = "%s ORDER BY %s".format(e.toSQL, ordering.map(o => "%s %s".format(o._1.columnName, o._2.toSQL)).mkString(","))
      def arguments = e.arguments
    }
    
    class ColumnDefExpression[T](c: ColumnDef[T]) {
      def ===(t: T) = new BasicExpression(c, "=",  t)
      def < (t: T)  = new BasicExpression(c, "<",  t)
      def <=(t: T)  = new BasicExpression(c, "<=", t)
      def > (t: T)  = new BasicExpression(c, ">",  t)
      def >=(t: T)  = new BasicExpression(c, ">=", t)
      def in(t: Seq[T]) = new Expression {
        def toSQL = "%s in (%s)".format(c.columnName, List.make(t.length, "?").mkString(","))
        def arguments = t
      }
        
    }
    
    implicit def colToExpression[T](c: ColumnDef[T]) = new ColumnDefExpression(c)

    trait Row {
      private[Database] val fields = MMap[ColumnDef[_], Any]()
      
      def table = Table.this
      
      def get[T](cd: ColumnDef[T]): T = {
        /*
        fields.foreach { case (c,v) =>
          println("col: "+c.columnName+" value: "+v)
        }
        */
        fields.get(cd).getOrElse(cd.defaultValue).asInstanceOf[T]
      }
      
      def set[T](c: ColumnDef[T], value: T): T = {
        fields += ((c, value))
        value
      }
      
      def get[T <: Database.this.Table](r: ToOneRelation[T]): T = {
        error("todo")
      }
      
      override def equals(other: Any): Boolean = {
        if (other.isInstanceOf[Row]) {
          val o = other.asInstanceOf[Row]
          if (o.table == this.table) {
            return fields.forall { case (c,v) =>
              val ((oc, ov)) = o.fields(c)
              ((oc == c) && (ov == v))
            }
          }
        }
        false
      }
      
      def save: Unit = error("todo")
    }

    protected def createKey(key: PK): ROW
    
    protected def createRow: ROW
    
    implicit def primaryKeyValue(r: ROW): PK

    override def toString = "Table: " + (if (tableName != null) tableName else "NO_NAME?")
    
    Database.this += Table.this
    
  }

  trait PrimaryKey1[A] { self: Table =>
    type PK = Product1[A]
    def primaryKey: ColumnDef[A] 
    def find(a: A) = self.findKey(Tuple1(a))
    def create(a: A) = self.createKey(Tuple1(a))
    def createKey(pk: PK): ROW = {
      val row = createRow
      row.set(primaryKey, pk._1)
      row
    }
    def primaryKeyValue(row: ROW): PK = Tuple1(row.get(primaryKey))
  }
  
  trait PrimaryKey2[A,B] { self: Table =>
    type PK = Product2[A,B]
    def primaryKeys: (ColumnDef[A], ColumnDef[B]) 
    def find(a: A, b: B) = self.findKey((a,b))
    def create(a: A, b: B) = self.createKey((a,b))
    def createKey(pk: PK): ROW = {
      val row = createRow
      row.set(primaryKeys._1, pk._1)
      row.set(primaryKeys._2, pk._2)
      row
    }
    def primaryKeyValue(row: ROW): PK = (row.get(primaryKeys._1), row.get(primaryKeys._2))
  }

  trait PrimaryKey3[A,B,C] { self: Table =>
    type PK = Product3[A,B,C]
    def primaryKeys: (ColumnDef[A], ColumnDef[B], ColumnDef[C]) 
    def find(a: A, b: B, c: C) = self.findKey((a,b,c))
    def create(a: A, b: B, c: C) = self.createKey((a,b,c))
    def createKey(pk: PK): ROW = {
      val row = createRow
      row.set(primaryKeys._1, pk._1)
      row.set(primaryKeys._2, pk._2)
      row.set(primaryKeys._3, pk._3)
      row
    }
    def primaryKeyValue(row: ROW): PK = 
      (row.get(primaryKeys._1), row.get(primaryKeys._2), row.get(primaryKeys._3))
  }

  trait Column[T] {
    def name: String
  }

  def toSeq(p: Product) : Seq[Any] = p match {
    case Product1(a) => List(a._1)
    case Product2(a,b) => List(a,b)
    case Product3(a,b,c) => List(a,b,c)
    case Product4(a,b,c,d) => List(a,b,c,d)
    case Product5(a,b,c,d,e) => List(a,b,c,d,e)
    case Product6(a,b,c,d,e,f) => List(a,b,c,d,e,f)
    case Product7(a,b,c,d,e,f,g) => List(a,b,c,d,e,f,g)
    case Product8(a,b,c,d,e,f,g,h) => List(a,b,c,d,e,f,g,h)
    case Product9(a,b,c,d,e,f,g,h,i) => List(a,b,b,c,d,e,f,g,i)
  }
  
  def toTuple(s: Seq[_]): Product = {
    if (s.length == 1) Tuple1(s(0))
    else if (s.length == 2) (s(0), s(1))
    else if (s.length == 3) (s(0), s(1), s(2))
    else if (s.length == 4) (s(0), s(1), s(2), s(3))
    else if (s.length == 5) (s(0), s(1), s(2), s(3), s(4))
    else if (s.length == 6) (s(0), s(1), s(2), s(3), s(4), s(5))
    else if (s.length == 7) (s(0), s(1), s(2), s(3), s(4), s(5), s(6))
    else if (s.length == 8) (s(0), s(1), s(2), s(3), s(4), s(5), s(6), s(7))
    else if (s.length == 9) (s(0), s(1), s(2), s(3), s(4), s(5), s(6), s(7), s(8))
    else error("Sequence too long")
  }
  
  trait ToManyRelation[TABLE <: Table] {
    
  }
  trait ToOneRelation[TABLE <: Table] {
    
  }
  
  class OneToOneRelation   [FROM <: Table, TO <: Table](from: FROM, to: TO) extends ToOneRelation[TO]
  class OneToManyRelation  [TABLE <: Table](t: TABLE) extends ToManyRelation[TABLE]
  class ManyToOneRelation  [TABLE <: Table](t: TABLE) extends ToOneRelation[TABLE]
  class ManyToManyRelation [TABLE <: Table](t: TABLE) extends ToManyRelation[TABLE]
}

